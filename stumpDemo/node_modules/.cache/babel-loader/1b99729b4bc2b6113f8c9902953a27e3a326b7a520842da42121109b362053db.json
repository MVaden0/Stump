{"ast":null,"code":"export const jsParseCFG = {\n  symbols: [{\n    name: 'delimeter',\n    color: '#848bbd'\n  }, {\n    name: 'keyword',\n    color: '#fede5d'\n  }, {\n    name: 'variable',\n    color: '#ff7edb'\n  }, {\n    name: 'type',\n    color: '#fe4450'\n  }],\n  alphabet: [{\n    name: 'delimeter',\n    alphabet: ['.', ' ', '{', '}', '(', ')', '[', ']', ';', '=', '>', '<', '-', ':']\n  }, {\n    name: 'keyword',\n    alphabet: ['self', 'const', 'let', 'class', 'interface', 'constructor']\n  }, {\n    name: 'type',\n    alphabet: ['string', 'number']\n  }],\n  grammar: [{\n    name: 'type',\n    phrases: [['class ', ' {'], ['class ', '{'], ['interface ', ' {'], ['interface ', '{']]\n  }]\n};\nclass Parser {\n  /**\n   * Constructor for the Parser component.\n   * @param options \n   */\n  constructor(options) {\n    this.text = void 0;\n    this.CFGConfig = void 0;\n    this.parsedContent = void 0;\n    this.types = void 0;\n    this.alphabet = void 0;\n    this.parseKnownContent = () => {\n      this.alphabet.forEach(alphabet => {\n        let name = alphabet.name;\n\n        // get color for content\n        let color;\n        this.CFGConfig.symbols.forEach(symbol => {\n          if (symbol.name === name) {\n            color = symbol.color;\n          }\n        });\n\n        // color all known words\n        alphabet.alphabet.forEach(word => {\n          let index = 0;\n          while (index != -1) {\n            // get start and end indices for first instance of word\n            let startIndex = this.text.indexOf(word, index);\n            let endIndex;\n\n            // check if word is found\n            if (startIndex == -1) {\n              index = -1;\n            } else {\n              endIndex = startIndex + word.length;\n\n              // make new parsed content\n              let parsedContent = {\n                start: startIndex,\n                end: endIndex,\n                color: color,\n                content: word\n              };\n              this.parsedContent.push(parsedContent);\n              index = endIndex;\n            }\n          }\n        });\n      });\n    };\n    this.sortParsedContent = () => {\n      let sortedContent = [];\n      let sorted = 0;\n      let toSort = this.parsedContent.length;\n      let index = 0;\n      this.parsedContent.forEach(content => {\n        if (content.start == index) {\n          sortedContent.push(content);\n          sorted += 1;\n        }\n      });\n    };\n    this.parseContent = () => {\n      this.parseKnownContent();\n      this.sortParsedContent();\n    };\n    this.parseAlphabet = () => {\n      this.parseAlphabetFromConfig();\n      this.parseAlphabetFromGrammar();\n    };\n    this.parseAlphabetFromConfig = () => {\n      this.CFGConfig.alphabet.forEach(alphabet => {\n        this.alphabet.push(alphabet);\n      });\n    };\n    this.parseAlphabetFromGrammar = () => {\n      this.CFGConfig.grammar.forEach(grammar => {\n        let name = grammar.name;\n        grammar.phrases.forEach(phrase => {\n          // check if prefix and suffix found\n          let prefixIndex = this.text.indexOf(phrase[0]);\n          let suffixIndex = this.text.indexOf(phrase[1]);\n          if (prefixIndex != -1 && suffixIndex != -1) {\n            // regularize indices and extract new word\n            prefixIndex = prefixIndex + phrase[0].length;\n            suffixIndex = suffixIndex;\n            let word = this.text.substring(prefixIndex, suffixIndex);\n\n            // check if name already exist in alphabet\n            let nameFound = false;\n            this.alphabet.forEach(alphabet => {\n              if (name === alphabet.name) {\n                if (!alphabet.alphabet.includes(word.trim())) {\n                  alphabet.alphabet.push(word.trim());\n                }\n                nameFound = true;\n              }\n            });\n\n            // make new alphabet member if not\n            if (!nameFound) {\n              let newAlphabet = {\n                name: name,\n                alphabet: [word]\n              };\n              this.alphabet.push(newAlphabet);\n            }\n          }\n        });\n      });\n    };\n    this.render = () => {\n      let DOMContent = [];\n      return DOMContent;\n    };\n    this.text = options.text;\n    this.CFGConfig = options.CFGConfig;\n    this.parsedContent = [];\n    this.types = [];\n    this.alphabet = [];\n    this.parseAlphabet();\n    this.parseContent();\n  }\n\n  /**\n   * Parses content that can be determined from the alphabet.\n   */\n}\n\nexport default Parser;","map":{"version":3,"names":["jsParseCFG","symbols","name","color","alphabet","grammar","phrases","Parser","constructor","options","text","CFGConfig","parsedContent","types","parseKnownContent","forEach","symbol","word","index","startIndex","indexOf","endIndex","length","start","end","content","push","sortParsedContent","sortedContent","sorted","toSort","parseContent","parseAlphabet","parseAlphabetFromConfig","parseAlphabetFromGrammar","phrase","prefixIndex","suffixIndex","substring","nameFound","includes","trim","newAlphabet","render","DOMContent"],"sources":["/Users/michaelvaden/Desktop/Projects/stump/stump/src/components/Parser/Parser.tsx"],"sourcesContent":["export const jsParseCFG: ICFGConfig = {\n  symbols: [\n    {\n      name: 'delimeter',\n      color: '#848bbd'\n    },\n    {\n      name: 'keyword',\n      color: '#fede5d'\n    },\n    {\n      name: 'variable',\n      color: '#ff7edb'\n    },\n    {\n      name: 'type',\n      color: '#fe4450'\n    },\n  ],\n  alphabet: [\n    {\n      name: 'delimeter',\n      alphabet: ['.', ' ', '{', '}', '(', ')', '[', ']', ';', '=', '>', '<', '-', ':']\n    },\n    {\n      name: 'keyword',\n      alphabet: ['self', 'const', 'let', 'class', 'interface', 'constructor']\n    },\n    {\n      name: 'type',\n      alphabet: ['string', 'number']\n    }\n  ],\n  grammar: [\n    {\n      name: 'type',\n      phrases: [\n        ['class ', ' {'],\n        ['class ', '{'],\n        ['interface ', ' {'],\n        ['interface ', '{']\n      ]\n    }\n  ]\n}\n\ninterface ISymbol {\n  name: string,\n  color: string\n}\n\ninterface IAlphabet {\n  name: string,\n  alphabet: string[]\n}\n\ninterface IGrammar {\n  name: string,\n  phrases: string[][]\n}\n\ninterface ICFGConfig {\n  symbols: ISymbol[],\n  alphabet: IAlphabet[],\n  grammar: IGrammar[]\n}\n\ninterface IParsedContent {\n  start: number,\n  end: number,\n  color: string,\n  content: string\n}\n\ninterface ParserOptions {\n  text: string,\n  CFGConfig: ICFGConfig\n}\n\nclass Parser {\n  text: string\n  CFGConfig: ICFGConfig\n  parsedContent: IParsedContent[]\n  types: string[]\n  alphabet: IAlphabet[]\n\n  /**\n   * Constructor for the Parser component.\n   * @param options \n   */\n  constructor(options: ParserOptions) {\n    this.text = options.text\n    this.CFGConfig = options.CFGConfig\n    this.parsedContent = []\n    this.types = []\n    this.alphabet = []\n\n    this.parseAlphabet()\n    this.parseContent()\n  }\n\n  /**\n   * Parses content that can be determined from the alphabet.\n   */\n  parseKnownContent = () => {\n    this.alphabet.forEach((alphabet) => {\n      let name: string = alphabet.name\n\n      // get color for content\n      let color: string\n\n      this.CFGConfig.symbols.forEach((symbol) => {\n        if (symbol.name === name) {\n          color = symbol.color\n        }\n      })\n  \n      // color all known words\n      alphabet.alphabet.forEach((word) => {\n        let index: number = 0\n\n        while (index != -1) {\n          // get start and end indices for first instance of word\n          let startIndex: number = this.text.indexOf(word, index)\n          let endIndex: number\n\n          // check if word is found\n          if (startIndex == -1) {\n            index = -1\n          } else {\n            endIndex = startIndex + word.length\n\n            // make new parsed content\n            let parsedContent: IParsedContent = {\n              start: startIndex,\n              end: endIndex,\n              color: color,\n              content: word\n            }\n\n            this.parsedContent.push(parsedContent)\n\n            index = endIndex\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Sorts content that can be parse from known alphabet.\n   */\n  sortParsedContent = () => {\n    let sortedContent: IParsedContent[] = []\n    let sorted: number = 0\n    let toSort: number = this.parsedContent.length\n    let index: number = 0\n\n\n    this.parsedContent.forEach((content) => {\n      if (content.start == index) {\n        sortedContent.push(content)\n        sorted += 1\n      }\n    })\n  }\n\n  /**\n   * Parses text into content.\n   */\n  parseContent = () => {\n    this.parseKnownContent()\n    this.sortParsedContent()\n\n  }\n\n  /**\n   * Parses the alphabet to be used in this Parser from both an alphabet given from the config \n   * and an alphabet determined by the grammar.\n   */\n  parseAlphabet = () => {\n    this.parseAlphabetFromConfig()\n    this.parseAlphabetFromGrammar()\n  }\n\n  /**\n   * Parses the alphabet to be used in this parser from an alphabet given by the config.\n   */\n  parseAlphabetFromConfig = () => {\n    this.CFGConfig.alphabet.forEach((alphabet) => {\n      this.alphabet.push(alphabet)\n    })\n  }\n\n  /**\n   * Parses the alphabet to be used in this parser from an alphabet determined by the grammar.\n   */\n  parseAlphabetFromGrammar = () => {\n    this.CFGConfig.grammar.forEach((grammar) => {\n      let name: string = grammar.name\n\n      grammar.phrases.forEach((phrase) => {\n        // check if prefix and suffix found\n        let prefixIndex: number = this.text.indexOf(phrase[0])\n        let suffixIndex: number = this.text.indexOf(phrase[1])\n\n        if (prefixIndex != -1 && suffixIndex != -1) {\n          // regularize indices and extract new word\n          prefixIndex = prefixIndex + phrase[0].length\n          suffixIndex = suffixIndex\n\n          let word: string = this.text.substring(prefixIndex, suffixIndex)\n\n          // check if name already exist in alphabet\n          let nameFound: boolean = false\n\n          this.alphabet.forEach((alphabet) => {\n            if (name === alphabet.name) {\n              if (!alphabet.alphabet.includes(word.trim())) {\n                alphabet.alphabet.push(word.trim())\n              }\n              \n              nameFound = true\n            }\n          })\n\n          // make new alphabet member if not\n          if (!nameFound) {\n            let newAlphabet: IAlphabet = {\n              name: name,\n              alphabet: [word]\n            }\n\n            this.alphabet.push(newAlphabet)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Returns the elements to be rendered to the code block.\n   * @returns parsed array of colored elements\n   */\n  render = () => {\n    let DOMContent: JSX.Element[] = []\n    return DOMContent\n  }\n}\n\nexport default Parser"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}