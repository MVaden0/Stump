{"ast":null,"code":"export const jsParseCFG = {\n  symbols: [{\n    name: 'delimeter',\n    color: '#848bbd'\n  }, {\n    name: 'keyword',\n    color: '#fede5d'\n  }, {\n    name: 'variable',\n    color: '#ff7edb'\n  }, {\n    name: 'type',\n    color: '#fe4450'\n  }],\n  alphabet: [{\n    name: 'delimeter',\n    alphabet: ['.', ' ', '{', '}', '(', ')', '[', ']', ';', '=', '>', '<', '-', ':']\n  }, {\n    name: 'keyword',\n    alphabet: ['self', 'const', 'let', 'class', 'interface', 'constructor']\n  }, {\n    name: 'type',\n    alphabet: ['string', 'number']\n  }],\n  grammar: [{\n    name: 'type',\n    phrases: [['class ', ' {'], ['class ', '{'], ['interface ', ' {'], ['interface ', '{']]\n  }]\n};\nclass Parser {\n  /**\n   * Constructor for the Parser component.\n   * @param options \n   */\n  constructor(options) {\n    this.text = void 0;\n    this.CFGConfig = void 0;\n    this.parsedContent = void 0;\n    this.types = void 0;\n    this.alphabet = void 0;\n    this.parseAlphabet = () => {\n      this.parseAlphabetFromConfig();\n      this.parseAlphabetFromGrammar();\n    };\n    this.parseAlphabetFromConfig = () => {\n      this.CFGConfig.alphabet.forEach(alphabet => {\n        this.alphabet.push(alphabet);\n      });\n    };\n    this.parseAlphabetFromGrammar = () => {\n      this.CFGConfig.grammar.forEach(grammar => {\n        let name = grammar.name;\n        grammar.phrases.forEach(phrase => {\n          // check if prefix and suffix found\n          let prefixIndex = this.text.indexOf(phrase[0]);\n          let suffixIndex = this.text.indexOf(phrase[1]);\n          if (prefixIndex != -1 && suffixIndex != -1) {\n            // regularize indices and extract new word\n            prefixIndex = prefixIndex + phrase[0].length;\n            suffixIndex = suffixIndex;\n            let word = this.text.substring(prefixIndex, suffixIndex);\n\n            // check if name already exist in alphabet\n            let nameFound = false;\n            this.alphabet.forEach(alphabet => {\n              if (name === alphabet.name) {\n                if (!alphabet.alphabet.includes(word.trim())) {\n                  alphabet.alphabet.push(word.trim());\n                }\n                nameFound = true;\n              }\n            });\n\n            // make new alphabet member if not\n            if (!nameFound) {\n              let newAlphabet = {\n                name: name,\n                alphabet: [word]\n              };\n              this.alphabet.push(newAlphabet);\n            }\n          }\n        });\n      });\n    };\n    this.parseContent = () => {\n      this.alphabet.forEach(alphabet => {\n        let name = alphabet.name;\n        alphabet.alphabet.forEach(word => {});\n      });\n    };\n    this.render = () => {\n      return this.parsedContent;\n    };\n    this.text = options.text;\n    this.CFGConfig = options.CFGConfig;\n    this.parsedContent = [];\n    this.types = [];\n    this.alphabet = [];\n    this.parseAlphabet();\n  }\n\n  /**\n   * Parses the alphabet to be used in this Parser from both an alphabet given from the config \n   * and an alphabet determined by the grammar.\n   */\n}\n\nexport default Parser;","map":{"version":3,"names":["jsParseCFG","symbols","name","color","alphabet","grammar","phrases","Parser","constructor","options","text","CFGConfig","parsedContent","types","parseAlphabet","parseAlphabetFromConfig","parseAlphabetFromGrammar","forEach","push","phrase","prefixIndex","indexOf","suffixIndex","length","word","substring","nameFound","includes","trim","newAlphabet","parseContent","render"],"sources":["/Users/michaelvaden/Desktop/Projects/stump/stump/src/components/Parser/Parser.tsx"],"sourcesContent":["export const jsParseCFG: ICFGConfig = {\n  symbols: [\n    {\n      name: 'delimeter',\n      color: '#848bbd'\n    },\n    {\n      name: 'keyword',\n      color: '#fede5d'\n    },\n    {\n      name: 'variable',\n      color: '#ff7edb'\n    },\n    {\n      name: 'type',\n      color: '#fe4450'\n    },\n  ],\n  alphabet: [\n    {\n      name: 'delimeter',\n      alphabet: ['.', ' ', '{', '}', '(', ')', '[', ']', ';', '=', '>', '<', '-', ':']\n    },\n    {\n      name: 'keyword',\n      alphabet: ['self', 'const', 'let', 'class', 'interface', 'constructor']\n    },\n    {\n      name: 'type',\n      alphabet: ['string', 'number']\n    }\n  ],\n  grammar: [\n    {\n      name: 'type',\n      phrases: [\n        ['class ', ' {'],\n        ['class ', '{'],\n        ['interface ', ' {'],\n        ['interface ', '{']\n      ]\n    }\n  ]\n}\n\ninterface ISymbol {\n  name: string,\n  color: string\n}\n\ninterface IAlphabet {\n  name: string,\n  alphabet: string[]\n}\n\ninterface IGrammar {\n  name: string,\n  phrases: string[][]\n}\n\ninterface ICFGConfig {\n  symbols: ISymbol[],\n  alphabet: IAlphabet[],\n  grammar: IGrammar[]\n}\n\ninterface ParserOptions {\n  text: string,\n  CFGConfig: ICFGConfig\n}\n\nclass Parser {\n  text: string\n  CFGConfig: ICFGConfig\n  parsedContent: JSX.Element[]\n  types: string[]\n  alphabet: IAlphabet[]\n\n  /**\n   * Constructor for the Parser component.\n   * @param options \n   */\n  constructor(options: ParserOptions) {\n    this.text = options.text\n    this.CFGConfig = options.CFGConfig\n    this.parsedContent = []\n    this.types = []\n    this.alphabet = []\n\n    this.parseAlphabet()\n  }\n\n  /**\n   * Parses the alphabet to be used in this Parser from both an alphabet given from the config \n   * and an alphabet determined by the grammar.\n   */\n  parseAlphabet = () => {\n    this.parseAlphabetFromConfig()\n    this.parseAlphabetFromGrammar()\n  }\n\n  /**\n   * Parses the alphabet to be used in this parser from an alphabet given by the config.\n   */\n  parseAlphabetFromConfig = () => {\n    this.CFGConfig.alphabet.forEach((alphabet) => {\n      this.alphabet.push(alphabet)\n    })\n  }\n\n  /**\n   * Parses the alphabet to be used in this parser from an alphabet determined by the grammar.\n   */\n  parseAlphabetFromGrammar = () => {\n    this.CFGConfig.grammar.forEach((grammar) => {\n      let name: string = grammar.name\n\n      grammar.phrases.forEach((phrase) => {\n        // check if prefix and suffix found\n        let prefixIndex: number = this.text.indexOf(phrase[0])\n        let suffixIndex: number = this.text.indexOf(phrase[1])\n\n        if (prefixIndex != -1 && suffixIndex != -1) {\n          // regularize indices and extract new word\n          prefixIndex = prefixIndex + phrase[0].length\n          suffixIndex = suffixIndex\n\n          let word: string = this.text.substring(prefixIndex, suffixIndex)\n\n          // check if name already exist in alphabet\n          let nameFound: boolean = false\n\n          this.alphabet.forEach((alphabet) => {\n            if (name === alphabet.name) {\n              if (!alphabet.alphabet.includes(word.trim())) {\n                alphabet.alphabet.push(word.trim())\n              }\n              \n              nameFound = true\n            }\n          })\n\n          // make new alphabet member if not\n          if (!nameFound) {\n            let newAlphabet: IAlphabet = {\n              name: name,\n              alphabet: [word]\n            }\n\n            this.alphabet.push(newAlphabet)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Parses text into content.\n   */\n  parseContent = () => {\n    this.alphabet.forEach((alphabet) => {\n      let name: string = alphabet.name\n      \n      alphabet.alphabet.forEach((word) => {\n        \n      })\n    })\n  }\n\n  /**\n   * Returns the elements to be rendered to the code block.\n   * @returns parsed array of colored elements\n   */\n  render = () => {\n    return this.parsedContent\n  }\n}\n\nexport default Parser"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}