{"ast":null,"code":"export const jsParseCFG = {\n  variableColor: '#ff7edb',\n  symbols: [{\n    name: 'delimeter',\n    color: '#848bbd'\n  }, {\n    name: 'keyword',\n    color: '#fede5d'\n  }, {\n    name: 'type',\n    color: '#fe4450'\n  }],\n  alphabet: [{\n    name: 'delimeter',\n    alphabet: ['.', ' ', '{', '}', '(', ')', '[', ']', ';', '=', '>', '<', '-', ':']\n  }, {\n    name: 'keyword',\n    alphabet: ['self', 'const', 'let', 'class', 'interface', 'constructor']\n  }, {\n    name: 'type',\n    alphabet: ['string', 'number']\n  }],\n  grammar: [{\n    name: 'type',\n    phrases: [['class ', ' {'], ['class ', '{'], ['interface ', ' {'], ['interface ', '{']]\n  }]\n};\nclass Parser {\n  /**\n   * Constructor for the Parser component.\n   * @param options \n   */\n  constructor(options) {\n    this.text = void 0;\n    this.CFGConfig = void 0;\n    this.parsedContent = void 0;\n    this.types = void 0;\n    this.alphabet = void 0;\n    this.parseKnownContent = () => {\n      this.alphabet.forEach(alphabet => {\n        let name = alphabet.name;\n\n        // get color for content\n        let color;\n        this.CFGConfig.symbols.forEach(symbol => {\n          if (symbol.name === name) {\n            color = symbol.color;\n          }\n        });\n\n        // color all known words\n        alphabet.alphabet.forEach(word => {\n          let index = 0;\n          while (index !== -1) {\n            // get start and end indices for first instance of word\n            let startIndex = this.text.indexOf(word, index);\n            let endIndex;\n\n            // check if word is found\n            if (startIndex === -1) {\n              index = -1;\n            } else {\n              endIndex = startIndex + word.length;\n\n              // make new parsed content\n              let parsedContent = {\n                start: startIndex,\n                end: endIndex,\n                color: color,\n                content: word\n              };\n              this.parsedContent.push(parsedContent);\n              index = endIndex;\n            }\n          }\n        });\n      });\n    };\n    this.swap = (x, y) => {\n      var temp = this.parsedContent[x];\n      this.parsedContent[x] = this.parsedContent[y];\n      this.parsedContent[y] = temp;\n    };\n    this.sortParsedContent = () => {\n      let i = 0;\n      let j = 0;\n      for (i = 0; i < this.parsedContent.length - 1; i++) {\n        for (j = 0; j < this.parsedContent.length - i - 1; j++) {\n          if (this.parsedContent[j].start > this.parsedContent[j + 1].start) {\n            this.swap(j, j + 1);\n          }\n        }\n      }\n    };\n    this.insertAtIndex = (index, replacement) => {\n      // shift last element\n      let lastIndex = this.parsedContent.length - 1;\n      this.parsedContent.push(this.parsedContent[lastIndex]);\n\n      // shift all other elements\n      for (let i = this.parsedContent.length - 2; i >= index; i++) {\n        this.parsedContent[i + 1] = this.parsedContent[i];\n      }\n\n      // replace content\n      this.parsedContent[index] = replacement;\n    };\n    this.parseUnknownContent = () => {\n      // determine color\n      let color = this.CFGConfig.variableColor;\n      for (let i = 0; i < this.parsedContent.length - 2; i++) {\n        if (this.parsedContent[i].start !== this.parsedContent[i + 1].end) {\n          let start = this.parsedContent[i].end;\n          let end = this.parsedContent[i + 1].start;\n          let replacementContent = {\n            start: start,\n            end: end,\n            color: color,\n            content: this.text.substring(start, end)\n          };\n\n          //this.insertAtIndex(i, replacementContent)\n        }\n      }\n    };\n    this.parseContent = () => {\n      this.parseKnownContent();\n      this.sortParsedContent();\n      this.parseUnknownContent();\n    };\n    this.parseAlphabet = () => {\n      this.parseAlphabetFromConfig();\n      this.parseAlphabetFromGrammar();\n    };\n    this.parseAlphabetFromConfig = () => {\n      this.CFGConfig.alphabet.forEach(alphabet => {\n        this.alphabet.push(alphabet);\n      });\n    };\n    this.parseAlphabetFromGrammar = () => {\n      this.CFGConfig.grammar.forEach(grammar => {\n        let name = grammar.name;\n        grammar.phrases.forEach(phrase => {\n          // check if prefix and suffix found\n          let prefixIndex = this.text.indexOf(phrase[0]);\n          let suffixIndex = this.text.indexOf(phrase[1]);\n          if (prefixIndex !== -1 && suffixIndex !== -1) {\n            // regularize indices and extract new word\n            prefixIndex = prefixIndex + phrase[0].length;\n            suffixIndex = suffixIndex;\n            let word = this.text.substring(prefixIndex, suffixIndex);\n\n            // check if name already exist in alphabet\n            let nameFound = false;\n            this.alphabet.forEach(alphabet => {\n              if (name === alphabet.name) {\n                if (!alphabet.alphabet.includes(word.trim())) {\n                  alphabet.alphabet.push(word.trim());\n                }\n                nameFound = true;\n              }\n            });\n\n            // make new alphabet member if not\n            if (!nameFound) {\n              let newAlphabet = {\n                name: name,\n                alphabet: [word]\n              };\n              this.alphabet.push(newAlphabet);\n            }\n          }\n        });\n      });\n    };\n    this.render = () => {\n      let DOMContent = [];\n      return DOMContent;\n    };\n    this.text = options.text;\n    this.CFGConfig = options.CFGConfig;\n    this.parsedContent = [];\n    this.types = [];\n    this.alphabet = [];\n    this.parseAlphabet();\n    this.parseContent();\n  }\n\n  /**\n   * Parses content that can be determined from the alphabet.\n   */\n}\n\nexport default Parser;","map":{"version":3,"names":["jsParseCFG","variableColor","symbols","name","color","alphabet","grammar","phrases","Parser","constructor","options","text","CFGConfig","parsedContent","types","parseKnownContent","forEach","symbol","word","index","startIndex","indexOf","endIndex","length","start","end","content","push","swap","x","y","temp","sortParsedContent","i","j","insertAtIndex","replacement","lastIndex","parseUnknownContent","replacementContent","substring","parseContent","parseAlphabet","parseAlphabetFromConfig","parseAlphabetFromGrammar","phrase","prefixIndex","suffixIndex","nameFound","includes","trim","newAlphabet","render","DOMContent"],"sources":["/Users/michaelvaden/Desktop/Projects/stump/stump/src/components/Parser/Parser.tsx"],"sourcesContent":["export const jsParseCFG: ICFGConfig = {\n  variableColor: '#ff7edb',\n  symbols: [\n    {\n      name: 'delimeter',\n      color: '#848bbd'\n    },\n    {\n      name: 'keyword',\n      color: '#fede5d'\n    },\n    {\n      name: 'type',\n      color: '#fe4450'\n    },\n  ],\n  alphabet: [\n    {\n      name: 'delimeter',\n      alphabet: ['.', ' ', '{', '}', '(', ')', '[', ']', ';', '=', '>', '<', '-', ':']\n    },\n    {\n      name: 'keyword',\n      alphabet: ['self', 'const', 'let', 'class', 'interface', 'constructor']\n    },\n    {\n      name: 'type',\n      alphabet: ['string', 'number']\n    }\n  ],\n  grammar: [\n    {\n      name: 'type',\n      phrases: [\n        ['class ', ' {'],\n        ['class ', '{'],\n        ['interface ', ' {'],\n        ['interface ', '{']\n      ]\n    }\n  ]\n}\n\ninterface ISymbol {\n  name: string,\n  color: string\n}\n\ninterface IAlphabet {\n  name: string,\n  alphabet: string[]\n}\n\ninterface IGrammar {\n  name: string,\n  phrases: string[][]\n}\n\ninterface ICFGConfig {\n  variableColor: string,\n  symbols: ISymbol[],\n  alphabet: IAlphabet[],\n  grammar: IGrammar[]\n}\n\ninterface IParsedContent {\n  start: number,\n  end: number,\n  color: string,\n  content: string\n}\n\ninterface ParserOptions {\n  text: string,\n  CFGConfig: ICFGConfig\n}\n\nclass Parser {\n  text: string\n  CFGConfig: ICFGConfig\n  parsedContent: IParsedContent[]\n  types: string[]\n  alphabet: IAlphabet[]\n\n  /**\n   * Constructor for the Parser component.\n   * @param options \n   */\n  constructor(options: ParserOptions) {\n    this.text = options.text\n    this.CFGConfig = options.CFGConfig\n    this.parsedContent = []\n    this.types = []\n    this.alphabet = []\n\n    this.parseAlphabet()\n    this.parseContent()\n  }\n\n  /**\n   * Parses content that can be determined from the alphabet.\n   */\n  parseKnownContent = () => {\n    this.alphabet.forEach((alphabet) => {\n      let name: string = alphabet.name\n\n      // get color for content\n      let color: string\n\n      this.CFGConfig.symbols.forEach((symbol) => {\n        if (symbol.name === name) {\n          color = symbol.color\n        }\n      })\n  \n      // color all known words\n      alphabet.alphabet.forEach((word) => {\n        let index: number = 0\n\n        while (index !== -1) {\n          // get start and end indices for first instance of word\n          let startIndex: number = this.text.indexOf(word, index)\n          let endIndex: number\n\n          // check if word is found\n          if (startIndex === -1) {\n            index = -1\n          } else {\n            endIndex = startIndex + word.length\n\n            // make new parsed content\n            let parsedContent: IParsedContent = {\n              start: startIndex,\n              end: endIndex,\n              color: color,\n              content: word\n            }\n\n            this.parsedContent.push(parsedContent)\n\n            index = endIndex\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Used for BubbleSort purposes\n   * @param x first number to swap\n   * @param y second number to swap\n   */\n  swap = (x: number, y: number) => {\n    var temp = this.parsedContent[x]\n    this.parsedContent[x] = this.parsedContent[y]\n    this.parsedContent[y] = temp\n  }\n\n  /**\n   * Sorts content that can be parse from known alphabet.\n   */\n  sortParsedContent = () => {\n    let i: number = 0\n    let j: number = 0\n\n    for (i = 0; i < this.parsedContent.length - 1; i++) {\n        for (j = 0; j < this.parsedContent.length - i - 1; j++) {\n            if (this.parsedContent[j].start > this.parsedContent[j + 1].start) {\n              this.swap(j, j + 1)\n            }\n        }\n    }\n  }\n\n  /**\n   * Inserts parsed content at a specified index.\n   */\n  insertAtIndex = (index: number, replacement: IParsedContent) => {\n    // shift last element\n    let lastIndex: number = this.parsedContent.length - 1\n\n    this.parsedContent.push(this.parsedContent[lastIndex])\n\n    // shift all other elements\n    for (let i = this.parsedContent.length - 2; i >= index; i++) {\n      this.parsedContent[i + 1] = this.parsedContent[i]\n    }\n\n    // replace content\n    this.parsedContent[index] = replacement\n  }\n\n  /**\n   * Parse all other content that cannot be determined from alphabet.\n   */\n  parseUnknownContent = () => {\n    // determine color\n    let color: string = this.CFGConfig.variableColor\n\n    \n    for (let i = 0; i < this.parsedContent.length - 2; i++) {\n      \n      if (this.parsedContent[i].start !== this.parsedContent[i + 1].end) {\n        let start: number = this.parsedContent[i].end\n        let end: number = this.parsedContent[i + 1].start\n\n        let replacementContent: IParsedContent = {\n          start: start,\n          end: end,\n          color: color,\n          content: this.text.substring(start, end)\n        }\n\n        //this.insertAtIndex(i, replacementContent)\n      }\n    }\n  }\n\n  /**\n   * Parses text into content.\n   */\n  parseContent = () => {\n    this.parseKnownContent()\n    this.sortParsedContent()\n    this.parseUnknownContent()\n  }\n\n  /**\n   * Parses the alphabet to be used in this Parser from both an alphabet given from the config \n   * and an alphabet determined by the grammar.\n   */\n  parseAlphabet = () => {\n    this.parseAlphabetFromConfig()\n    this.parseAlphabetFromGrammar()\n  }\n\n  /**\n   * Parses the alphabet to be used in this parser from an alphabet given by the config.\n   */\n  parseAlphabetFromConfig = () => {\n    this.CFGConfig.alphabet.forEach((alphabet) => {\n      this.alphabet.push(alphabet)\n    })\n  }\n\n  /**\n   * Parses the alphabet to be used in this parser from an alphabet determined by the grammar.\n   */\n  parseAlphabetFromGrammar = () => {\n    this.CFGConfig.grammar.forEach((grammar) => {\n      let name: string = grammar.name\n\n      grammar.phrases.forEach((phrase) => {\n        // check if prefix and suffix found\n        let prefixIndex: number = this.text.indexOf(phrase[0])\n        let suffixIndex: number = this.text.indexOf(phrase[1])\n\n        if (prefixIndex !== -1 && suffixIndex !== -1) {\n          // regularize indices and extract new word\n          prefixIndex = prefixIndex + phrase[0].length\n          suffixIndex = suffixIndex\n\n          let word: string = this.text.substring(prefixIndex, suffixIndex)\n\n          // check if name already exist in alphabet\n          let nameFound: boolean = false\n\n          this.alphabet.forEach((alphabet) => {\n            if (name === alphabet.name) {\n              if (!alphabet.alphabet.includes(word.trim())) {\n                alphabet.alphabet.push(word.trim())\n              }\n              \n              nameFound = true\n            }\n          })\n\n          // make new alphabet member if not\n          if (!nameFound) {\n            let newAlphabet: IAlphabet = {\n              name: name,\n              alphabet: [word]\n            }\n\n            this.alphabet.push(newAlphabet)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Returns the elements to be rendered to the code block.\n   * @returns parsed array of colored elements\n   */\n  render = () => {\n    let DOMContent: JSX.Element[] = []\n    return DOMContent\n  }\n}\n\nexport default Parser"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}