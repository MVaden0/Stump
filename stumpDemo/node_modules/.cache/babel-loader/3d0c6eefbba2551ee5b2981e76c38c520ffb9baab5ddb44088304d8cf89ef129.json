{"ast":null,"code":"var _jsxFileName = \"/Users/michaelvaden/Desktop/Projects/stump/stump/src/components/Parser/Parser.tsx\";\nimport React from 'react';\nimport styles from './Parser.module.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const jsParseCFG = {\n  variableColor: '#ff7edb',\n  symbols: [{\n    name: 'delimeter',\n    color: '#848bbd'\n  }, {\n    name: 'keyword',\n    color: '#fede5d'\n  }, {\n    name: 'type',\n    color: '#fe4450'\n  }],\n  alphabet: [{\n    name: 'delimeter',\n    alphabet: ['.', ' ', '{', '}', '(', ')', '[', ']', ';', '=', '>', '<', '-', ':']\n  }, {\n    name: 'keyword',\n    alphabet: ['self', 'const', 'let', 'class', 'interface', 'constructor']\n  }, {\n    name: 'type',\n    alphabet: ['string', 'number']\n  }],\n  grammar: [{\n    name: 'type',\n    phrases: [['class ', ' {'], ['class ', '{'], ['interface ', ' {'], ['interface ', '{']]\n  }]\n};\nclass Parser {\n  /**\n   * Constructor for the Parser component.\n   * @param options \n   */\n  constructor(options) {\n    this.text = void 0;\n    this.CFGConfig = void 0;\n    this.parsedContent = void 0;\n    this.parsedRows = void 0;\n    this.types = void 0;\n    this.alphabet = void 0;\n    this.parseKnownContent = () => {\n      this.alphabet.forEach(alphabet => {\n        let name = alphabet.name;\n\n        // get color for content\n        let color;\n        this.CFGConfig.symbols.forEach(symbol => {\n          if (symbol.name === name) {\n            color = symbol.color;\n          }\n        });\n\n        // color all known words\n        alphabet.alphabet.forEach(word => {\n          let index = 0;\n          while (index !== -1) {\n            // get start and end indices for first instance of word\n            let startIndex = this.text.indexOf(word, index);\n            let endIndex;\n\n            // check if word is found\n            if (startIndex === -1) {\n              index = -1;\n            } else {\n              endIndex = startIndex + word.length;\n\n              // make new parsed content\n              let parsedContent = {\n                start: startIndex,\n                end: endIndex,\n                color: color,\n                content: word\n              };\n              this.parsedContent.push(parsedContent);\n              index = endIndex;\n            }\n          }\n        });\n      });\n    };\n    this.swap = (x, y) => {\n      var temp = this.parsedContent[x];\n      this.parsedContent[x] = this.parsedContent[y];\n      this.parsedContent[y] = temp;\n    };\n    this.sortParsedContent = () => {\n      let i = 0;\n      let j = 0;\n      for (i = 0; i < this.parsedContent.length - 1; i++) {\n        for (j = 0; j < this.parsedContent.length - i - 1; j++) {\n          if (this.parsedContent[j].start > this.parsedContent[j + 1].start) {\n            this.swap(j, j + 1);\n          }\n        }\n      }\n    };\n    this.parseUnknownContent = () => {\n      // determine color\n      let color = this.CFGConfig.variableColor;\n      for (let i = 0; i < this.parsedContent.length - 1; i++) {\n        if (this.parsedContent[i].end != this.parsedContent[i + 1].start) {\n          let start = this.parsedContent[i].end;\n          let end = this.parsedContent[i + 1].start;\n          let replacementContent = {\n            start: start,\n            end: end,\n            color: color,\n            content: this.text.substring(start, end)\n          };\n          this.parsedContent.splice(i + 1, 0, replacementContent);\n        }\n      }\n\n      // check if unknown content is at beginning of text\n      if (this.parsedContent[0].start > 0) {\n        let start = 0;\n        let end = this.parsedContent[0].start;\n        let replacementContent = {\n          start: start,\n          end: end,\n          color: color,\n          content: this.text.substring(start, end)\n        };\n        this.parsedContent.splice(0, 0, replacementContent);\n      }\n      // check if unknown content is at end of text\n      if (this.parsedContent[this.parsedContent.length - 1].end < this.text.length) {\n        let start = this.parsedContent[this.parsedContent.length - 1].end;\n        let end = this.text.length;\n        let replacementContent = {\n          start: start,\n          end: end,\n          color: color,\n          content: this.text.substring(start, end)\n        };\n        this.parsedContent.splice(this.parsedContent.length, 0, replacementContent);\n      }\n    };\n    this.parseContent = () => {\n      this.parseKnownContent();\n      this.sortParsedContent();\n      this.parseUnknownContent();\n    };\n    this.parseAlphabet = () => {\n      this.parseAlphabetFromConfig();\n      this.parseAlphabetFromGrammar();\n    };\n    this.parseAlphabetFromConfig = () => {\n      this.CFGConfig.alphabet.forEach(alphabet => {\n        this.alphabet.push(alphabet);\n      });\n    };\n    this.parseAlphabetFromGrammar = () => {\n      this.CFGConfig.grammar.forEach(grammar => {\n        let name = grammar.name;\n        grammar.phrases.forEach(phrase => {\n          // check if prefix and suffix found\n          let prefixIndex = this.text.indexOf(phrase[0]);\n          let suffixIndex = this.text.indexOf(phrase[1]);\n          if (prefixIndex !== -1 && suffixIndex !== -1) {\n            // regularize indices and extract new word\n            prefixIndex = prefixIndex + phrase[0].length;\n            suffixIndex = suffixIndex;\n            let word = this.text.substring(prefixIndex, suffixIndex);\n\n            // check if name already exist in alphabet\n            let nameFound = false;\n            this.alphabet.forEach(alphabet => {\n              if (name === alphabet.name) {\n                if (!alphabet.alphabet.includes(word.trim())) {\n                  alphabet.alphabet.push(word.trim());\n                }\n                nameFound = true;\n              }\n            });\n\n            // make new alphabet member if not\n            if (!nameFound) {\n              let newAlphabet = {\n                name: name,\n                alphabet: [word]\n              };\n              this.alphabet.push(newAlphabet);\n            }\n          }\n        });\n      });\n    };\n    this.parseRows = () => {\n      // start on some index\n      // loop through parsed content until a newline is found\n      // if a newline isn't found, put nodes from index to end in an array\n      // if newline is found, then set index to index + 1 and repeat\n      let rows = [];\n      let startIndex = 0;\n      let index = 0;\n      for (let i = 0; i < this.parsedContent.length; i++) {\n        let newlineFound = this.parsedContent[i].content.includes('\\n');\n        if (newlineFound) {\n          rows.push(this.parsedContent.slice(startIndex, i));\n          startIndex = i;\n        } else {\n          if (i == this.parsedContent.length - 1) {\n            rows.push(this.parsedContent.slice(startIndex, this.parsedContent.length));\n          }\n        }\n      }\n      this.parsedRows = rows;\n      console.log(JSON.stringify(rows));\n    };\n    this.parseTabs = () => {\n      for (let i = 0; i < this.parsedRows.length; i++) {\n        for (let j = 0; j < this.parsedRows[i].length; j++) {\n          let replacement = this.parsedRows[i][j].content.replace('\\t', '\\u00A0\\u00A0\\u00A0\\u00A0');\n          this.parsedRows[i][j].content = replacement;\n        }\n      }\n    };\n    this.renderRow = content => {\n      return content.map((content, key) => {\n        return /*#__PURE__*/_jsxDEV(\"span\", {\n          className: styles.stumpSpanClass,\n          style: {\n            color: content.color\n          },\n          children: content.content\n        }, key, false, {\n          fileName: _jsxFileName,\n          lineNumber: 357,\n          columnNumber: 9\n        }, this);\n      });\n    };\n    this.render = () => {\n      return /*#__PURE__*/_jsxDEV(\"ul\", {\n        className: styles.stumpListClass,\n        children: this.parsedRows.map((content, key) => {\n          return /*#__PURE__*/_jsxDEV(\"li\", {\n            children: this.renderRow(content)\n          }, key, false, {\n            fileName: _jsxFileName,\n            lineNumber: 372,\n            columnNumber: 15\n          }, this);\n        })\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 368,\n        columnNumber: 7\n      }, this);\n    };\n    this.text = options.text;\n    this.CFGConfig = options.CFGConfig;\n    this.parsedContent = [];\n    this.parsedRows = [];\n    this.types = [];\n    this.alphabet = [];\n    this.parseAlphabet();\n    this.parseContent();\n    this.parseRows();\n    this.parseTabs();\n  }\n\n  /**\n   * Parses content that can be determined from the alphabet.\n   */\n}\n\nexport default Parser;","map":{"version":3,"names":["React","styles","jsParseCFG","variableColor","symbols","name","color","alphabet","grammar","phrases","Parser","constructor","options","text","CFGConfig","parsedContent","parsedRows","types","parseKnownContent","forEach","symbol","word","index","startIndex","indexOf","endIndex","length","start","end","content","push","swap","x","y","temp","sortParsedContent","i","j","parseUnknownContent","replacementContent","substring","splice","parseContent","parseAlphabet","parseAlphabetFromConfig","parseAlphabetFromGrammar","phrase","prefixIndex","suffixIndex","nameFound","includes","trim","newAlphabet","parseRows","rows","newlineFound","slice","console","log","JSON","stringify","parseTabs","replacement","replace","renderRow","map","key","stumpSpanClass","render","stumpListClass"],"sources":["/Users/michaelvaden/Desktop/Projects/stump/stump/src/components/Parser/Parser.tsx"],"sourcesContent":["import React from 'react'\nimport styles from './Parser.module.css'\n\nexport const jsParseCFG: ICFGConfig = {\n  variableColor: '#ff7edb',\n  symbols: [\n    {\n      name: 'delimeter',\n      color: '#848bbd'\n    },\n    {\n      name: 'keyword',\n      color: '#fede5d'\n    },\n    {\n      name: 'type',\n      color: '#fe4450'\n    },\n  ],\n  alphabet: [\n    {\n      name: 'delimeter',\n      alphabet: ['.', ' ', '{', '}', '(', ')', '[', ']', ';', '=', '>', '<', '-', ':']\n    },\n    {\n      name: 'keyword',\n      alphabet: ['self', 'const', 'let', 'class', 'interface', 'constructor']\n    },\n    {\n      name: 'type',\n      alphabet: ['string', 'number']\n    }\n  ],\n  grammar: [\n    {\n      name: 'type',\n      phrases: [\n        ['class ', ' {'],\n        ['class ', '{'],\n        ['interface ', ' {'],\n        ['interface ', '{']\n      ]\n    }\n  ]\n}\n\ninterface ISymbol {\n  name: string,\n  color: string\n}\n\ninterface IAlphabet {\n  name: string,\n  alphabet: string[]\n}\n\ninterface IGrammar {\n  name: string,\n  phrases: string[][]\n}\n\ninterface ICFGConfig {\n  variableColor: string,\n  symbols: ISymbol[],\n  alphabet: IAlphabet[],\n  grammar: IGrammar[]\n}\n\ninterface IParsedContent {\n  start: number,\n  end: number,\n  color: string,\n  content: string\n}\n\ninterface ParserOptions {\n  text: string,\n  CFGConfig: ICFGConfig\n}\n\nclass Parser {\n  text: string\n  CFGConfig: ICFGConfig\n  parsedContent: IParsedContent[]\n  parsedRows: IParsedContent[][]\n  types: string[]\n  alphabet: IAlphabet[]\n\n  /**\n   * Constructor for the Parser component.\n   * @param options \n   */\n  constructor(options: ParserOptions) {\n    this.text = options.text\n    this.CFGConfig = options.CFGConfig\n    this.parsedContent = []\n    this.parsedRows = []\n    this.types = []\n    this.alphabet = []\n\n    this.parseAlphabet()\n    this.parseContent()\n    this.parseRows()\n    this.parseTabs()\n  }\n\n  /**\n   * Parses content that can be determined from the alphabet.\n   */\n  parseKnownContent = () => {\n    this.alphabet.forEach((alphabet) => {\n      let name: string = alphabet.name\n\n      // get color for content\n      let color: string\n\n      this.CFGConfig.symbols.forEach((symbol) => {\n        if (symbol.name === name) {\n          color = symbol.color\n        }\n      })\n  \n      // color all known words\n      alphabet.alphabet.forEach((word) => {\n        let index: number = 0\n\n        while (index !== -1) {\n          // get start and end indices for first instance of word\n          let startIndex: number = this.text.indexOf(word, index)\n          let endIndex: number\n\n          // check if word is found\n          if (startIndex === -1) {\n            index = -1\n          } else {\n            endIndex = startIndex + word.length\n\n            // make new parsed content\n            let parsedContent: IParsedContent = {\n              start: startIndex,\n              end: endIndex,\n              color: color,\n              content: word\n            }\n\n            this.parsedContent.push(parsedContent)\n\n            index = endIndex\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Used for BubbleSort purposes\n   * @param x first number to swap\n   * @param y second number to swap\n   */\n  swap = (x: number, y: number) => {\n    var temp = this.parsedContent[x]\n    this.parsedContent[x] = this.parsedContent[y]\n    this.parsedContent[y] = temp\n  }\n\n  /**\n   * Sorts content that can be parse from known alphabet.\n   */\n  sortParsedContent = () => {\n    let i: number = 0\n    let j: number = 0\n\n    for (i = 0; i < this.parsedContent.length - 1; i++) {\n        for (j = 0; j < this.parsedContent.length - i - 1; j++) {\n            if (this.parsedContent[j].start > this.parsedContent[j + 1].start) {\n              this.swap(j, j + 1)\n            }\n        }\n    }\n  }\n\n  /**\n   * Parse all other content that cannot be determined from alphabet.\n   */\n  parseUnknownContent = () => {\n    // determine color\n    let color: string = this.CFGConfig.variableColor\n\n    for (let i = 0; i < this.parsedContent.length - 1; i++) {\n      if (this.parsedContent[i].end != this.parsedContent[i + 1].start) {\n        let start: number = this.parsedContent[i].end\n        let end: number = this.parsedContent[i + 1].start\n\n        let replacementContent: IParsedContent = {\n          start: start,\n          end: end,\n          color: color,\n          content: this.text.substring(start, end)\n        }\n\n        this.parsedContent.splice(i + 1, 0, replacementContent);\n      }\n    }\n\n    // check if unknown content is at beginning of text\n    if (this.parsedContent[0].start > 0) {\n      let start: number = 0\n      let end: number = this.parsedContent[0].start\n\n      let replacementContent: IParsedContent = {\n        start: start,\n        end: end,\n        color: color,\n        content: this.text.substring(start, end)\n      }\n\n      this.parsedContent.splice(0, 0, replacementContent);\n    } \n    // check if unknown content is at end of text\n    if (this.parsedContent[this.parsedContent.length - 1].end < this.text.length) {\n      let start: number = this.parsedContent[this.parsedContent.length - 1].end\n      let end: number = this.text.length\n\n      let replacementContent: IParsedContent = {\n        start: start,\n        end: end,\n        color: color,\n        content: this.text.substring(start, end)\n      }\n\n      this.parsedContent.splice(this.parsedContent.length, 0, replacementContent);\n    }\n  }\n\n  /**\n   * Parses text into content.\n   */\n  parseContent = () => {\n    this.parseKnownContent()\n    this.sortParsedContent()\n    this.parseUnknownContent()\n  }\n\n  /**\n   * Parses the alphabet to be used in this Parser from both an alphabet given from the config \n   * and an alphabet determined by the grammar.\n   */\n  parseAlphabet = () => {\n    this.parseAlphabetFromConfig()\n    this.parseAlphabetFromGrammar()\n  }\n\n  /**\n   * Parses the alphabet to be used in this parser from an alphabet given by the config.\n   */\n  parseAlphabetFromConfig = () => {\n    this.CFGConfig.alphabet.forEach((alphabet) => {\n      this.alphabet.push(alphabet)\n    })\n  }\n\n  /**\n   * Parses the alphabet to be used in this parser from an alphabet determined by the grammar.\n   */\n  parseAlphabetFromGrammar = () => {\n    this.CFGConfig.grammar.forEach((grammar) => {\n      let name: string = grammar.name\n\n      grammar.phrases.forEach((phrase) => {\n        // check if prefix and suffix found\n        let prefixIndex: number = this.text.indexOf(phrase[0])\n        let suffixIndex: number = this.text.indexOf(phrase[1])\n\n        if (prefixIndex !== -1 && suffixIndex !== -1) {\n          // regularize indices and extract new word\n          prefixIndex = prefixIndex + phrase[0].length\n          suffixIndex = suffixIndex\n\n          let word: string = this.text.substring(prefixIndex, suffixIndex)\n\n          // check if name already exist in alphabet\n          let nameFound: boolean = false\n\n          this.alphabet.forEach((alphabet) => {\n            if (name === alphabet.name) {\n              if (!alphabet.alphabet.includes(word.trim())) {\n                alphabet.alphabet.push(word.trim())\n              }\n              \n              nameFound = true\n            }\n          })\n\n          // make new alphabet member if not\n          if (!nameFound) {\n            let newAlphabet: IAlphabet = {\n              name: name,\n              alphabet: [word]\n            }\n\n            this.alphabet.push(newAlphabet)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Parses content into rows based on newlines.\n   */\n  parseRows = () => {\n    // start on some index\n    // loop through parsed content until a newline is found\n    // if a newline isn't found, put nodes from index to end in an array\n    // if newline is found, then set index to index + 1 and repeat\n    let rows: IParsedContent[][] = []\n    let startIndex: number = 0\n    let index: number = 0\n\n    for (let i = 0; i < this.parsedContent.length; i++) {\n      let newlineFound: boolean = this.parsedContent[i].content.includes('\\n')\n\n      if (newlineFound) {\n        rows.push(this.parsedContent.slice(startIndex, i))\n        startIndex = i\n\n      } else {\n        if (i == this.parsedContent.length - 1) {\n          rows.push(this.parsedContent.slice(startIndex, this.parsedContent.length))\n        }\n      }\n    }\n\n    this.parsedRows = rows\n    console.log(JSON.stringify(rows))\n  }\n\n  /**\n   * Parses all elements that have a tab in them.\n   */\n  parseTabs = () => {\n    for (let i = 0; i < this.parsedRows.length; i++) {\n      for (let j = 0; j < this.parsedRows[i].length; j++) {\n        let replacement: string = this.parsedRows[i][j].content.replace('\\t', '\\u00A0\\u00A0\\u00A0\\u00A0')\n        this.parsedRows[i][j].content = replacement\n      }\n    }\n  }\n\n  /**\n   * Renders a single row of words.\n   * @returns a the row of words\n   */\n  renderRow = (content: IParsedContent[]) => {\n    return content.map((content, key) => {\n      return (\n        <span key={key} className={styles.stumpSpanClass} style={{color: content.color}}>{content.content}</span>\n      )\n    })\n  }\n\n  /**\n   * Returns the elements to be rendered to the code block.\n   * @returns parsed array of colored elements\n   */\n  render = () => {\n    return (\n      <ul className={styles.stumpListClass}>\n        {\n          this.parsedRows.map((content, key) => {\n            return (\n              <li key={key}>{this.renderRow(content)}</li>\n            )\n          })\n        }\n      </ul>\n    )\n  }\n}\n\nexport default Parser"],"mappings":";AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,OAAOC,MAAM,MAAM,qBAAqB;AAAA;AAExC,OAAO,MAAMC,UAAsB,GAAG;EACpCC,aAAa,EAAE,SAAS;EACxBC,OAAO,EAAE,CACP;IACEC,IAAI,EAAE,WAAW;IACjBC,KAAK,EAAE;EACT,CAAC,EACD;IACED,IAAI,EAAE,SAAS;IACfC,KAAK,EAAE;EACT,CAAC,EACD;IACED,IAAI,EAAE,MAAM;IACZC,KAAK,EAAE;EACT,CAAC,CACF;EACDC,QAAQ,EAAE,CACR;IACEF,IAAI,EAAE,WAAW;IACjBE,QAAQ,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG;EACjF,CAAC,EACD;IACEF,IAAI,EAAE,SAAS;IACfE,QAAQ,EAAE,CAAC,MAAM,EAAE,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE,WAAW,EAAE,aAAa;EACxE,CAAC,EACD;IACEF,IAAI,EAAE,MAAM;IACZE,QAAQ,EAAE,CAAC,QAAQ,EAAE,QAAQ;EAC/B,CAAC,CACF;EACDC,OAAO,EAAE,CACP;IACEH,IAAI,EAAE,MAAM;IACZI,OAAO,EAAE,CACP,CAAC,QAAQ,EAAE,IAAI,CAAC,EAChB,CAAC,QAAQ,EAAE,GAAG,CAAC,EACf,CAAC,YAAY,EAAE,IAAI,CAAC,EACpB,CAAC,YAAY,EAAE,GAAG,CAAC;EAEvB,CAAC;AAEL,CAAC;AAoCD,MAAMC,MAAM,CAAC;EAQX;AACF;AACA;AACA;EACEC,WAAW,CAACC,OAAsB,EAAE;IAAA,KAXpCC,IAAI;IAAA,KACJC,SAAS;IAAA,KACTC,aAAa;IAAA,KACbC,UAAU;IAAA,KACVC,KAAK;IAAA,KACLV,QAAQ;IAAA,KAuBRW,iBAAiB,GAAG,MAAM;MACxB,IAAI,CAACX,QAAQ,CAACY,OAAO,CAAEZ,QAAQ,IAAK;QAClC,IAAIF,IAAY,GAAGE,QAAQ,CAACF,IAAI;;QAEhC;QACA,IAAIC,KAAa;QAEjB,IAAI,CAACQ,SAAS,CAACV,OAAO,CAACe,OAAO,CAAEC,MAAM,IAAK;UACzC,IAAIA,MAAM,CAACf,IAAI,KAAKA,IAAI,EAAE;YACxBC,KAAK,GAAGc,MAAM,CAACd,KAAK;UACtB;QACF,CAAC,CAAC;;QAEF;QACAC,QAAQ,CAACA,QAAQ,CAACY,OAAO,CAAEE,IAAI,IAAK;UAClC,IAAIC,KAAa,GAAG,CAAC;UAErB,OAAOA,KAAK,KAAK,CAAC,CAAC,EAAE;YACnB;YACA,IAAIC,UAAkB,GAAG,IAAI,CAACV,IAAI,CAACW,OAAO,CAACH,IAAI,EAAEC,KAAK,CAAC;YACvD,IAAIG,QAAgB;;YAEpB;YACA,IAAIF,UAAU,KAAK,CAAC,CAAC,EAAE;cACrBD,KAAK,GAAG,CAAC,CAAC;YACZ,CAAC,MAAM;cACLG,QAAQ,GAAGF,UAAU,GAAGF,IAAI,CAACK,MAAM;;cAEnC;cACA,IAAIX,aAA6B,GAAG;gBAClCY,KAAK,EAAEJ,UAAU;gBACjBK,GAAG,EAAEH,QAAQ;gBACbnB,KAAK,EAAEA,KAAK;gBACZuB,OAAO,EAAER;cACX,CAAC;cAED,IAAI,CAACN,aAAa,CAACe,IAAI,CAACf,aAAa,CAAC;cAEtCO,KAAK,GAAGG,QAAQ;YAClB;UACF;QACF,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC;IAAA,KAODM,IAAI,GAAG,CAACC,CAAS,EAAEC,CAAS,KAAK;MAC/B,IAAIC,IAAI,GAAG,IAAI,CAACnB,aAAa,CAACiB,CAAC,CAAC;MAChC,IAAI,CAACjB,aAAa,CAACiB,CAAC,CAAC,GAAG,IAAI,CAACjB,aAAa,CAACkB,CAAC,CAAC;MAC7C,IAAI,CAAClB,aAAa,CAACkB,CAAC,CAAC,GAAGC,IAAI;IAC9B,CAAC;IAAA,KAKDC,iBAAiB,GAAG,MAAM;MACxB,IAAIC,CAAS,GAAG,CAAC;MACjB,IAAIC,CAAS,GAAG,CAAC;MAEjB,KAAKD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACrB,aAAa,CAACW,MAAM,GAAG,CAAC,EAAEU,CAAC,EAAE,EAAE;QAChD,KAAKC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACtB,aAAa,CAACW,MAAM,GAAGU,CAAC,GAAG,CAAC,EAAEC,CAAC,EAAE,EAAE;UACpD,IAAI,IAAI,CAACtB,aAAa,CAACsB,CAAC,CAAC,CAACV,KAAK,GAAG,IAAI,CAACZ,aAAa,CAACsB,CAAC,GAAG,CAAC,CAAC,CAACV,KAAK,EAAE;YACjE,IAAI,CAACI,IAAI,CAACM,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC;UACrB;QACJ;MACJ;IACF,CAAC;IAAA,KAKDC,mBAAmB,GAAG,MAAM;MAC1B;MACA,IAAIhC,KAAa,GAAG,IAAI,CAACQ,SAAS,CAACX,aAAa;MAEhD,KAAK,IAAIiC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACrB,aAAa,CAACW,MAAM,GAAG,CAAC,EAAEU,CAAC,EAAE,EAAE;QACtD,IAAI,IAAI,CAACrB,aAAa,CAACqB,CAAC,CAAC,CAACR,GAAG,IAAI,IAAI,CAACb,aAAa,CAACqB,CAAC,GAAG,CAAC,CAAC,CAACT,KAAK,EAAE;UAChE,IAAIA,KAAa,GAAG,IAAI,CAACZ,aAAa,CAACqB,CAAC,CAAC,CAACR,GAAG;UAC7C,IAAIA,GAAW,GAAG,IAAI,CAACb,aAAa,CAACqB,CAAC,GAAG,CAAC,CAAC,CAACT,KAAK;UAEjD,IAAIY,kBAAkC,GAAG;YACvCZ,KAAK,EAAEA,KAAK;YACZC,GAAG,EAAEA,GAAG;YACRtB,KAAK,EAAEA,KAAK;YACZuB,OAAO,EAAE,IAAI,CAAChB,IAAI,CAAC2B,SAAS,CAACb,KAAK,EAAEC,GAAG;UACzC,CAAC;UAED,IAAI,CAACb,aAAa,CAAC0B,MAAM,CAACL,CAAC,GAAG,CAAC,EAAE,CAAC,EAAEG,kBAAkB,CAAC;QACzD;MACF;;MAEA;MACA,IAAI,IAAI,CAACxB,aAAa,CAAC,CAAC,CAAC,CAACY,KAAK,GAAG,CAAC,EAAE;QACnC,IAAIA,KAAa,GAAG,CAAC;QACrB,IAAIC,GAAW,GAAG,IAAI,CAACb,aAAa,CAAC,CAAC,CAAC,CAACY,KAAK;QAE7C,IAAIY,kBAAkC,GAAG;UACvCZ,KAAK,EAAEA,KAAK;UACZC,GAAG,EAAEA,GAAG;UACRtB,KAAK,EAAEA,KAAK;UACZuB,OAAO,EAAE,IAAI,CAAChB,IAAI,CAAC2B,SAAS,CAACb,KAAK,EAAEC,GAAG;QACzC,CAAC;QAED,IAAI,CAACb,aAAa,CAAC0B,MAAM,CAAC,CAAC,EAAE,CAAC,EAAEF,kBAAkB,CAAC;MACrD;MACA;MACA,IAAI,IAAI,CAACxB,aAAa,CAAC,IAAI,CAACA,aAAa,CAACW,MAAM,GAAG,CAAC,CAAC,CAACE,GAAG,GAAG,IAAI,CAACf,IAAI,CAACa,MAAM,EAAE;QAC5E,IAAIC,KAAa,GAAG,IAAI,CAACZ,aAAa,CAAC,IAAI,CAACA,aAAa,CAACW,MAAM,GAAG,CAAC,CAAC,CAACE,GAAG;QACzE,IAAIA,GAAW,GAAG,IAAI,CAACf,IAAI,CAACa,MAAM;QAElC,IAAIa,kBAAkC,GAAG;UACvCZ,KAAK,EAAEA,KAAK;UACZC,GAAG,EAAEA,GAAG;UACRtB,KAAK,EAAEA,KAAK;UACZuB,OAAO,EAAE,IAAI,CAAChB,IAAI,CAAC2B,SAAS,CAACb,KAAK,EAAEC,GAAG;QACzC,CAAC;QAED,IAAI,CAACb,aAAa,CAAC0B,MAAM,CAAC,IAAI,CAAC1B,aAAa,CAACW,MAAM,EAAE,CAAC,EAAEa,kBAAkB,CAAC;MAC7E;IACF,CAAC;IAAA,KAKDG,YAAY,GAAG,MAAM;MACnB,IAAI,CAACxB,iBAAiB,EAAE;MACxB,IAAI,CAACiB,iBAAiB,EAAE;MACxB,IAAI,CAACG,mBAAmB,EAAE;IAC5B,CAAC;IAAA,KAMDK,aAAa,GAAG,MAAM;MACpB,IAAI,CAACC,uBAAuB,EAAE;MAC9B,IAAI,CAACC,wBAAwB,EAAE;IACjC,CAAC;IAAA,KAKDD,uBAAuB,GAAG,MAAM;MAC9B,IAAI,CAAC9B,SAAS,CAACP,QAAQ,CAACY,OAAO,CAAEZ,QAAQ,IAAK;QAC5C,IAAI,CAACA,QAAQ,CAACuB,IAAI,CAACvB,QAAQ,CAAC;MAC9B,CAAC,CAAC;IACJ,CAAC;IAAA,KAKDsC,wBAAwB,GAAG,MAAM;MAC/B,IAAI,CAAC/B,SAAS,CAACN,OAAO,CAACW,OAAO,CAAEX,OAAO,IAAK;QAC1C,IAAIH,IAAY,GAAGG,OAAO,CAACH,IAAI;QAE/BG,OAAO,CAACC,OAAO,CAACU,OAAO,CAAE2B,MAAM,IAAK;UAClC;UACA,IAAIC,WAAmB,GAAG,IAAI,CAAClC,IAAI,CAACW,OAAO,CAACsB,MAAM,CAAC,CAAC,CAAC,CAAC;UACtD,IAAIE,WAAmB,GAAG,IAAI,CAACnC,IAAI,CAACW,OAAO,CAACsB,MAAM,CAAC,CAAC,CAAC,CAAC;UAEtD,IAAIC,WAAW,KAAK,CAAC,CAAC,IAAIC,WAAW,KAAK,CAAC,CAAC,EAAE;YAC5C;YACAD,WAAW,GAAGA,WAAW,GAAGD,MAAM,CAAC,CAAC,CAAC,CAACpB,MAAM;YAC5CsB,WAAW,GAAGA,WAAW;YAEzB,IAAI3B,IAAY,GAAG,IAAI,CAACR,IAAI,CAAC2B,SAAS,CAACO,WAAW,EAAEC,WAAW,CAAC;;YAEhE;YACA,IAAIC,SAAkB,GAAG,KAAK;YAE9B,IAAI,CAAC1C,QAAQ,CAACY,OAAO,CAAEZ,QAAQ,IAAK;cAClC,IAAIF,IAAI,KAAKE,QAAQ,CAACF,IAAI,EAAE;gBAC1B,IAAI,CAACE,QAAQ,CAACA,QAAQ,CAAC2C,QAAQ,CAAC7B,IAAI,CAAC8B,IAAI,EAAE,CAAC,EAAE;kBAC5C5C,QAAQ,CAACA,QAAQ,CAACuB,IAAI,CAACT,IAAI,CAAC8B,IAAI,EAAE,CAAC;gBACrC;gBAEAF,SAAS,GAAG,IAAI;cAClB;YACF,CAAC,CAAC;;YAEF;YACA,IAAI,CAACA,SAAS,EAAE;cACd,IAAIG,WAAsB,GAAG;gBAC3B/C,IAAI,EAAEA,IAAI;gBACVE,QAAQ,EAAE,CAACc,IAAI;cACjB,CAAC;cAED,IAAI,CAACd,QAAQ,CAACuB,IAAI,CAACsB,WAAW,CAAC;YACjC;UACF;QACF,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC;IAAA,KAKDC,SAAS,GAAG,MAAM;MAChB;MACA;MACA;MACA;MACA,IAAIC,IAAwB,GAAG,EAAE;MACjC,IAAI/B,UAAkB,GAAG,CAAC;MAC1B,IAAID,KAAa,GAAG,CAAC;MAErB,KAAK,IAAIc,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACrB,aAAa,CAACW,MAAM,EAAEU,CAAC,EAAE,EAAE;QAClD,IAAImB,YAAqB,GAAG,IAAI,CAACxC,aAAa,CAACqB,CAAC,CAAC,CAACP,OAAO,CAACqB,QAAQ,CAAC,IAAI,CAAC;QAExE,IAAIK,YAAY,EAAE;UAChBD,IAAI,CAACxB,IAAI,CAAC,IAAI,CAACf,aAAa,CAACyC,KAAK,CAACjC,UAAU,EAAEa,CAAC,CAAC,CAAC;UAClDb,UAAU,GAAGa,CAAC;QAEhB,CAAC,MAAM;UACL,IAAIA,CAAC,IAAI,IAAI,CAACrB,aAAa,CAACW,MAAM,GAAG,CAAC,EAAE;YACtC4B,IAAI,CAACxB,IAAI,CAAC,IAAI,CAACf,aAAa,CAACyC,KAAK,CAACjC,UAAU,EAAE,IAAI,CAACR,aAAa,CAACW,MAAM,CAAC,CAAC;UAC5E;QACF;MACF;MAEA,IAAI,CAACV,UAAU,GAAGsC,IAAI;MACtBG,OAAO,CAACC,GAAG,CAACC,IAAI,CAACC,SAAS,CAACN,IAAI,CAAC,CAAC;IACnC,CAAC;IAAA,KAKDO,SAAS,GAAG,MAAM;MAChB,KAAK,IAAIzB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACpB,UAAU,CAACU,MAAM,EAAEU,CAAC,EAAE,EAAE;QAC/C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACrB,UAAU,CAACoB,CAAC,CAAC,CAACV,MAAM,EAAEW,CAAC,EAAE,EAAE;UAClD,IAAIyB,WAAmB,GAAG,IAAI,CAAC9C,UAAU,CAACoB,CAAC,CAAC,CAACC,CAAC,CAAC,CAACR,OAAO,CAACkC,OAAO,CAAC,IAAI,EAAE,0BAA0B,CAAC;UACjG,IAAI,CAAC/C,UAAU,CAACoB,CAAC,CAAC,CAACC,CAAC,CAAC,CAACR,OAAO,GAAGiC,WAAW;QAC7C;MACF;IACF,CAAC;IAAA,KAMDE,SAAS,GAAInC,OAAyB,IAAK;MACzC,OAAOA,OAAO,CAACoC,GAAG,CAAC,CAACpC,OAAO,EAAEqC,GAAG,KAAK;QACnC,oBACE;UAAgB,SAAS,EAAEjE,MAAM,CAACkE,cAAe;UAAC,KAAK,EAAE;YAAC7D,KAAK,EAAEuB,OAAO,CAACvB;UAAK,CAAE;UAAA,UAAEuB,OAAO,CAACA;QAAO,GAAtFqC,GAAG;UAAA;UAAA;UAAA;QAAA,QAA2F;MAE7G,CAAC,CAAC;IACJ,CAAC;IAAA,KAMDE,MAAM,GAAG,MAAM;MACb,oBACE;QAAI,SAAS,EAAEnE,MAAM,CAACoE,cAAe;QAAA,UAEjC,IAAI,CAACrD,UAAU,CAACiD,GAAG,CAAC,CAACpC,OAAO,EAAEqC,GAAG,KAAK;UACpC,oBACE;YAAA,UAAe,IAAI,CAACF,SAAS,CAACnC,OAAO;UAAC,GAA7BqC,GAAG;YAAA;YAAA;YAAA;UAAA,QAAgC;QAEhD,CAAC;MAAC;QAAA;QAAA;QAAA;MAAA,QAED;IAET,CAAC;IA5RC,IAAI,CAACrD,IAAI,GAAGD,OAAO,CAACC,IAAI;IACxB,IAAI,CAACC,SAAS,GAAGF,OAAO,CAACE,SAAS;IAClC,IAAI,CAACC,aAAa,GAAG,EAAE;IACvB,IAAI,CAACC,UAAU,GAAG,EAAE;IACpB,IAAI,CAACC,KAAK,GAAG,EAAE;IACf,IAAI,CAACV,QAAQ,GAAG,EAAE;IAElB,IAAI,CAACoC,aAAa,EAAE;IACpB,IAAI,CAACD,YAAY,EAAE;IACnB,IAAI,CAACW,SAAS,EAAE;IAChB,IAAI,CAACQ,SAAS,EAAE;EAClB;;EAEA;AACF;AACA;AA8QA;;AAEA,eAAenD,MAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}